'수백만 사용자를 지원하는 시스템을 설계하는 것은 도전적인 과제이며, 지속적인 계량과 끝없는 개선이 요구되는 여정이다.
한 명의 사용자를 지원하는 시스템에서 시작하여, 최종적으로 몇백만 사용자를 지원하는 시스템을 설계해 볼 것이다.'

## 1장. 사용자 수에 따른 규모 확장성
- - -


### 단일서버

모든 컴포넌트가 단 한대의 서버에서 실행되는 간단한 시스템

<img src="https://velog.velcdn.com/images/znzn9292/post/bb1b1c70-b763-4ab5-b9ce-184e37d710d4/image.png" width="60%" height="30%">



### 데이터베이스

사용자가 늘면 서버 하나로는 충분하지 않아서 여러 서버를 두어야 한다.
클라이언트 트래픽 처리 서버(웹 계층)와 데이터베이스 서버(데이터 계층)를 분리하면 그 각각을 독립적으로 확장해 나갈 수 있게 된다.


<img src="https://velog.velcdn.com/images/znzn9292/post/09df4243-048a-442d-904f-29266be63d5b/image.png" width="60%" height="30%">

> 어떤 데이터베이스를 사용할 것인가?
> 전통적인 **관계형 데이터베이스**와 **비-관계형 데이터베이스** 사이에서 고를 수 있다.
>
> **관계형 데이터베이스?**
> 자료를 테이블과 열, 칼럼으로 표현하고 SQL로 여러 테이블에 있는 데이터를 관계에 따라 조인연산이 가능하다.
>
> **비 관계형 데이터베이스?**
> NoSQL이라고도 부른다. 키-값 저장소, 그래프 저장소, 컬럼 저장소 등으로 분류 할 수 있다.
> 비-관계형 데이터베이스는 일반적으로 조인 연산은 지원하지않는다.
>
> **비-관계형 데이터베이스가 바람직한 선택인 경우**
> * 아주 낮은 응답 지연시간(latency)이 요구
> * 다루는 데이터가 비정형
> * 데이터(JSON, YAML, XML 등)를 직렬화하거나 역직렬화 할 수 있는 경우
> * 아주 많은 양의 데이터를 저장할 필요가 있음

### 수직적 규모 확장 vs 수평적 규모 확장
**스케일 업(Scale Up)**
수직적 규모 확장(Vertical Scaling) 프로세스로 서버에 고사양 자원을 추가하는 행위
* 구조가 단순하며 서버로 유입되는 트래픽의 양이 적을 때 좋은 선택
* 한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법은 없기에 한계가 존재
* 서버에 장애가 발생하면 웹사이트/앱 등 애플리케이션은 완전히 중단


**스케일 아웃(Scale Out)**
수평적 규모 확장 프로세스로 더 많은 서버를 추가하여 성능을 개선하는 행위
* 대규모 애플리케이션을 지원하는 데에 적합
* 트래픽에 따라 유동적으로 서버를 증설하고, 줄임으로써 비용의 효율화가 좋음
* 많은 트래픽으로 한계 상황에 도달할 경우 부하 분산기 또는 로드밸런서를 도입 가능


**로드밸런서 (Load Balancing)**
부하 분산 집합에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.

<img src="https://velog.velcdn.com/images/znzn9292/post/fd7e18a7-5ff3-4958-8aac-fb22bebe875d/image.png" width="60%" height="30%">

* 클라이언트는 로드밸런서의 공개 IP로 접속하고 웹 서버와 직접 접속 처리하지 않음
* 서버1이 다운되면 모든 트래픽은 서버2로 전송되어 애플리케이션이 다운되는 일을 방지
* 새로운 서버를 유동적으로 추가 하여 부하를 제어하고 웹 계층 가용성은 향상

**데이터베이스 다중화**
데이터베이스 서버 사이에 주(Master) - 부(Slave) 관계를 설정하고 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식이다.
**쓰기 연산(Write Operation)은 주 서버**에서 지원하고 부 서버는 주 서버로부터 데이터를 동기화 받으며, **읽기 연산(Read Operation)만을 지원**한다.
대부분의 애플리케이션은 읽기 연산의 비중이 쓰기 연산보자 훨씬 높아 통상적으로 **부 서버 수가 더 많다.**

<img src="https://velog.velcdn.com/images/znzn9292/post/2149c621-b381-45ca-9abd-3ad15cc1879d/image.png" width="60%" height="30%">

* 부 서버가 한 대 뿐인데 다운된 경우라면, 읽기 연산은 한시적으로 모두 주 서버로 전달
* 주 서버가 다운되면, 부 서버가 새로운 주 서버가 될 것이며 모든 데이터베이스 연산은 일시적으로 새로운 주 서버 상에서 수행


### 캐시
캐시는 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 접속 속도를 빠르게 처리 될 수 있도록 하는 저장소이다.
캐시 계층은 웹 서버와 데이터베이스 사이에 위치시켜 데이터베이스의 부하를 줄인다.

<img src="https://velog.velcdn.com/images/znzn9292/post/379e6231-989d-46f6-9c6a-4fa6845004ed/image.png" width="60%" height="50%">

캐시 사용 시 유의할 점
* 캐시는 휘발성 메모리이기에 영속적으로 보관할 데이터를 저장하는 것은 바람직하지 않음
* 캐시에 보관된 데이터의 만료 정책을 마련해 캐시 데이터가 증가함에 따라 오버헤드가 발생되지 않도록 유의
* 캐시가 꽉 차버리면 기존 데이터를 내보내는 방출 정책을 마련
  - LRU(Least REcently Used): 마지막으로 사용된 시점이 가장 오래된 데이터를 내보내는 정책
  - LFU(Least Frequently Used): 사용된 빈도가 사장 낮은 데이터를 내보내는 정책
  - FIFO(First In Fist Out): 가정 먼저 캐시에 들어온 데이터를 가장 먼저 내보내는 정책

### CDN
정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크이다. 이미지, 비디오, CSS, JS 파일 등을 캐시 할 수 있다.
사용자가 웹사이트를 방문하면, 그 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달한다.

### 무상태(Stateless) 웹 계층
상태 정보(사용자 세션 데이터와 같은)를 관계형 데이터베이스나 NoSQL 같은 지속성 저장소에 보관하고,
필요할 때 가져오도록 하는 것이 바람직한 전략이다. 이를 위해서는 상태 정보를 웹계층에서 제거하여야 한다.
이렇게 구성된 웹 계층을 무상태 웹 계층이라 부른다.

> _**상태 정보 의존적인 아키텍처**_
> 여러 서버는 사용자의 상태 정보를 공유되도록 한다.
>
> 사용자A -> 서버1
> 사용자B -> 서버2
> 사용자C -> 서버3
>
> 각 사용자의 상태 정보가 서로 다른 서버에서 관리 된다고 가정해보자
> 문제는 **같은 클라이언트로부터의 요청은 항상 같은 서버로 전송**되어야 한다는 것이다.
> 대부분 로드밸런서가 이를 지원하기 위해 **고정 세션(Stichy Session)** 기능을 제공하지만, 이는 로드밸런서에 부담을 준다.

<img src="https://velog.velcdn.com/images/znzn9292/post/a28c5b9c-4372-4697-a547-57cb523ace10/image.png" width="60%" height="30%">

* 상태 정보를 웹 계층에서 분리하고 지속성 데이터 보관소에 분리하여 저장(NoSQL)
* 서버의 자동 규모 확장성이 향상하고 트래픽 양에 따라 쉽게 대응이 가능

### 데이터 센터
장애 상황에 대비하기 위해 지리적으로 떨어진 데이터 센터에 서버를 위치시키는 것이 중요하다.
동일한 환경으로 이루어진 아키텍처를 데이터센터1(DC1), 데이터센트2(DC2)에 세팅한다.

<img src="https://velog.velcdn.com/images/znzn9292/post/b9e5d853-ed5f-4bc3-a2d6-71a17a0e0515/image.png" width="60%" height="30%">

* 데이터 센터 중 하나에 장애가 발생하면 모든 트래픽은 장애가 없는 데이터 센터로 전송
* 다중 데이터센터 아키텍처를 만들려면 기술적 난제를 해결

    - 트래픽 우회: 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾음
    - 데이터 동기화: 데이터 센터마다 별도의 데이터베이스를 사용하고 있는 상황이라면, 데이터의 동기화 문제 해결

### 메세지 큐
메세지의 무손실(durability)을 보장하는, 비동기 통신을 지원하는 컴포넌트다.
메세지의 버퍼 역할을 하며, 비동기적으로 전송한다.
생산자 또는 발행자(producer/publisher) 가 메세지를 만들어 메세지 큐에 발행(publish)한다.
메세지 큐에는 소비자 혹은 구독자(consumer/subscriber)라 불리는 서비스가 연결되어 큐에 있는 메세지를 소비한다.

<img src="https://velog.velcdn.com/images/znzn9292/post/8b7888d9-b71e-499b-aacf-783cd2bc5a33/image.png" width="60%" height="30%">

* 메세지 큐를 이용하면 서비스 또는 서버 간 결합이 느슨해져서, 규모 확장성이 보장되어야 하는 안정적 애필리케이션을 구성하기 좋음
* 생산자는 소비자 서버가 다운되어 있어도 메세지를 발핼 할 수 있고,
  소비자는 생산자 서버가 가용한 상태가 아니더라도 메세지를 수신할 수 있음

### 로그, 메트릭 그리고 자동화
* 로그: 시스템의 오류와 문제들을 보다 쉽게 찾아낼 수 있도록 한다.
  에러 로그는 서버 단위로 모니터링 할 수도 있지만, 로그를 단일 서비스로 모아주는 도구를 활용하면 더 편리하게 조회 할 수 있음
* 매트릭: 시스템의 현재 상태를 쉽게 파악할 수 있다.
* 자동화: 시스템이 크고 복잡해지면 생산성을 높이기 위해 자동화 도구를 활용해야 한다.
  빌드, 테스트, 배포 등의 절차를 자동화 할 수 있어 개발 생산성을 크게 향상시킬 수 있다.

### 데이터베이스의 규모 확장
저장할 데이터가 많아지면 데이터베이스에 대한 부하도 증가한다.
데이터베이스 규모를 확장하는 데는 두 가지 접근법이 있다.

>**수직적 확장**
스케일 업이라고도 부르는 수직적 규모 확장법
고성능의 자원(CPU, RAM, 디스크 등)을 증설하는 방법이다.
* 하드웨어에는 한계가 있으므로 CPU, RAM 등을 무한 증설할 수는 없음
* SPOF(Single Point Of Failure)로 인한 위험성이 큼
* 고성을 서버로 갈수록 가격이 올라가 비용 부담이 큼

>**수평적 확장**
데이터베이스의 수평적 확장은 **샤딩(Sharding)** 이라고 부른다.
샤딩은 대규모 데이터베이스를 샤드(shard)라고 부르는 작은 단위로 분할하는 기술을 일컫는다.

* 데이터의 재 샤딩
  재 샤딩은 다음과 같은 경우 필요
  (1). 데이터가 너무 많아져서 하나의 샤드로는 감당이 어려울 때
  (2). 샤드 간 데이터 분포가 균등하지 못하여 할당된 공간소모가 빨리 진행 될 때

* 유명인사(celebrity) 문제
  핫스팟 키 문제라도고 부르는데, 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제
  유명인사가 전부 같은 샤드에 저장되는 데이터베이스가 있는 경우 해당 샤드에는 read 연산으로 과부하가 걸리게 될 것이다.
  유명인사를 각각에 샤드 하나씩을 할당해야 할 수도 있고, 더 잘게 쪼개야 문제를 해결할 수 있다.

* 조인과 비정규화(join and de-normalization)
  하나의 데이터베이스를 여러 샤드 서버로 쪼개고 나면, 데이트럴 조인하기가 힘들어진다.
  데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 한다.


## 2장. 개략적인 규모 추정
---

### 모든 프로그래머가 알아야 하는 응답지연 값
컴퓨터에서 구현된 연산들의 응답지연 값
아래 수치들은 컴퓨터 연산들의 처리속도가 어느 정도인지 짐작할 수 있다.

| 연산명 | 시간 |
|---|---|
| L1 캐시 참조 | 0.5ns |
| 분기 예측 오류 | 5ns |
| L2 캐시 참조 | 7ns |
| 뮤텍스 락/언락 | 100ns |
| 주 메모리 참조 | 100ns |
| Zippy로 1KB 압축 | 10,000ns |
| 1 Gbps 네트워크로 2KB 전송 | 20,000ns |
| 메모리에서 1MB 순차적으로 read | 250,000ns |
| 같은 데이터 센터 내에서의 메시지 왕복 지연시간 | 500,000ns |
| 디스크 탐색 | 10,000,000ns |
| 네트워크에서 1MB 순차적으로 read | 10,000,000ns |
| 디스크에서 1MB 순자척으로 read | 30,000,000ns |
| 한 패킷의 CA로부터 네덜란드까지의 왕복 지연시간 | 150,000,000ns |
* 메모리는 빠르지만 디스크는 아직 느리다.
* 디스크 탐색은 가능한 한 피하라.
* 단순한 압축 알고리즘은 빠르다.
* 데이터를 인터넷으로 전송하기 전에 가능하면 압축해라.
* 데이터 센터는 보통 여러 지역에 분산되어 있고, 센터들 간에 데이터를 주고받는 데는 시간이 걸린다.

### 가용성에 관계된 수치들
고가용성(high availability)은 시스템이 오랜 시간 동안 지속적으로 중단 없이 운영될 수 있는 능력
고가용성을 표현하는 값은 퍼센트(percent)로 표현

## 3장. 시스템 설계 면접 공략법
---

### 효과적 면접을 위한 4단계 접근법

**_[1단계]_ _문제 이해 및 설계 범위 확정_**
* 생각 없이 바로 답을 내서는 좋은 점수를 받기 어렵다. 속도를 늦추고, 깊이 생각하고 질문하여 요구사항과 가정들을 분명히 하라.
* 질문에 대한 가정을 화이트보드나 종이에 적어두어라.

**_[2단계]_ _개략적인 설계안 제시 및 동의 구하기_**
* 면접관을 마치 팀원인 것처럼 대하라. 훌륭한 면접관들은 지원자들과 대화하고 설계 과정에 개입하기를 즐긴다.
* 화이트보드나 종이에 핵심 컴포넌트(서버, 캐시, CDN 등)를 포함하는 다이어그램을 그려라.

**_[3단계]_ _상세 설계_**
* 대부분의 면접관은 특정 시스템 컴포넌트들의 세부사항을 깊이 있게 설명하는 것을 보길 원한다.
* 시간 관리에 특별히 주의를 기울여야 한다. 사소한 세부사항을 설명하느라 정작 나의 능력을 보일 기회를 놓치면 안된다.

**_[4단계]_ _마무리_**
* 시스템 병목구간, 혹은 좀 더 개선 가능한 지점을 찾아 비판적 사고 능력을 보여라.
* 오류가 발생하면 무슨 일이 생기는지? 매트릭은 어떻게 수집하고 모니터링 할 것인가? 운영 이슈도 논의할 가치가 충분하다.
* 미래에 닥칠 규모 확정 요구에 어떻게 대처할 것인지도 흥미로운 주제다.









